# Java
## 并发编程
### CAS
- 简单介绍CAS的原理
  ~~~
  CAS全称是CompareAndSwap，比较交换的意思，是一种无锁算法，使用了CPU的指令级操作，是一种原子操作，CompareAndSwap有三个参数分别是：
  内存值，老的预期的内存值，新值；只有当内存值和老的预期内存在相同时，才会把内存值更新为新值，否则自旋继续比较。由于操作时CPU指令级别的，
  所以整个操作非常快，比加锁的性能高很多。但是会带来ABA问题，可以使用版本号解决。
  ~~~

### ConcurrentHashMap
- ConcurrentHashMap1.8的实现原理？
  ~~~
  1. 数据结构为：node数组+链表+红黑树的方式进行存储
  2. 采用分段锁的思想，在node数组中进行加锁，降低了锁的颗粒度，在低颗粒度锁情况下采用了synchronized+CAS的方式加锁，进一步优化效率
  3. 存储方式：数据通过Hash的方式存到node数组中，当出现Hash冲突的时候，会以链表(O（N）)的方式挂在到一个数组位置，当链表的长度大于8个时会以
     红黑树（O(logN)）的方式进行存储,当红黑树的节点小于等于6个时，会变成链表进行存储
  4. 扩容：
     4.1 当Node数组中的元素个数超过负载时（默认时0.75），会触发扩容
     4.2 当Node链表的个数大于8个并且Node数组小于64时，会触发扩容进行重新Hash而不是转为红黑树
     4.3 当putAll添加的元素个数大于Node数组的大小时，会触发扩容
     4.4 Node数组初始化为16个，每次扩容增加一倍（n<<1），扩容函数核心的使用的tranfer函数,使用sizeCtl字段控制并发扩容
  ~~~
- ConcurrentHashMap在1.7与1.8实现的区别？
  ~~~
   1. 数据结构的优化：1.7采用的是segment数组+HashEntry数组+链表的数据结构，1.8采用node数组+链表+红黑树的数据结构存储
     在存储方式上1.8的结构更简单一些
   2. 锁优化：1.7和1.8都使用了分段锁的思想，降低锁的颗粒度，提高并发，1.7针对segment进行锁定，1.8针对node数组进行锁定，锁的颗粒度更小；
      1.7使用了可重入锁reentrantlock,1.8采用的是synchronized+CAS的方式加锁，在低颗粒度锁的情况下synchronized优化度高
  ~~~
### 线程池
- 简述线程池的实现原理？
  ~~~
    线程池的全量参数构造函数： 
    public ThreadPoolExecutor(int corePoolSize,
                                 int maximumPoolSize,
                                 long keepAliveTime,
                                 TimeUnit unit,
                                 BlockingQueue<Runnable> workQueue,
                                 ThreadFactory threadFactory,
                                 RejectedExecutionHandler handler)
  线程池的一些核心概念：
  - 核心线程数：核心保留的线程数
  - 最大线程数：最大创建的线程数
  - 阻塞队列：任务队列，存放用户提交的任务
  - keepAliveTime/unit：线程存活时间，只对核心线程以外的
  - 线程工厂：创建线程并给出可读性强的线程名
  - 拒绝策略：当任务来不及处理的时候使用
  
  线程池的创建流程：
  1. 任务数小于核心线程数时，每个任务会新创建一个线程进行处理
  2. 任务数大于核心线程数时，任务会进入阻塞队列等待处理
  3. 当阻塞队列满时，会继续创建线程进行处理，但是最多不能超过最大线程数
  4. 当任务占满了最大线程数，继续进来的任务将触发拒绝策略，默认的是AbortPolicy,会抛出异常，其余的还有discard,discardOldest, CallerRuns
  5. 线程执行完任务后，大于核心线程数的线程会被回收，回收基于线程存活时间进行自动回收
  

  
  ~~~
  
- 如何优化线程池的配置？
~~~
CPU密集型：一般是配置为逻辑核心数(Runtime.getRuntime().abale)+1
IO密集型：一般配置为2*逻辑核心数+1
混合型：基于性能测试数据进行配置
~~~

### 并发安全
- 简述Java中的内存屏障？

## JVM
- 简单说明JVM的结构？
~~~
一般分为5块：
1.堆：线程共享，对象的生存的地方
2.虚拟机栈：线程私有，数据结构是栈帧，主要存放局部变量和操作数
3.本地方法栈：执行的是native方法
4.方法区：线程共享，存放类信息，常量，静态变量等
5.程序技术器：线程私有，空间小，当前线程的行号指示器
~~~
- 简述JVM加载机制？
~~~
~~~
- 简述JVM的双亲委派机制？
~~~
~~~
- 如何打破JVM的双亲委派机制？
~~~
加载 -> 链接(验证->准备->解析) -> 初始化 -> 使用 -> 卸载
- 加载：
  1. 基于类的全名来获取二进制字节流
  2. 将字节流所代表的静态结构转化为方法区的运行时数据结构
  3. 在堆中生成一个代表这个类的Class对象，作为方法区数据的访问入口
- 验证
  1. 确保加载类的正确性（文件格式验证；元数据验证；字节码验证；符号引用验证）
  2. 该阶段是可以关闭的，通过-Xverfity:none
- 准备
  1. 为类分配内存并初始化（静态类变量；变量的默认初始值）
- 解析
 

~~~

# MySQL
- 简述数据库的隔离级别？
- 简述数据库索引的数据结构和使用方法？